"""
file: time_handler.py
Time Handler for WT901BLECL5.0 devices

Author: Cristian Troncoso
Email: ctroncoso.ai@gmail.com
License: MIT
Version: 1.0.0
"""
import logging
from datetime import datetime, timezone
from typing import Optional

from dataclasses import dataclass, field


@dataclass
class TimeHandler():
    """
    The TimeHandler class is designed to generate and manage timestamps for
    measurements from a WT901BLECL5.0 device. Since the WT901BLECL5.0 device
    does not provide timestamps with its BLE data packets, this class helps the
    host system generate and synchronize timestamps, either using the host
    clock or by aligning with the device's time when available.

    The class provide a method to generate WIT messages to update the device's
    time registers and can be used to synchronize the host and device clocks.

    Note: The SAVE command is omitted intentionally to avoid excessive writes
    to non-volatile memory, as this update is performed frequently and
    persistence across power cycles is not required.


    Attributes
    ----------
    _update_rate (float):
        The expected update rate (Hz) for measurements. Used to calculate time
        intervals between samples.
    _initialized (bool):
        Tracks whether the handler has been initialized (first stamp generated).
    _device_curr_stamp_ms (float):
        Current timestamp in milliseconds, as tracked by the device or
        generated by the host.
    _device_time_offset (datetime):
        Device's reference time (not set in this code, but placeholder for
        future use).
    _host_time_offset (datetime):
        Host's reference time, set when set_host_time_offset() is called.
    _update_interval_ms (float):
        Time interval between samples in milliseconds. 
    """
    _update_rate: int = field(init=True, default=20)
    _initialized: bool = field(init=False, default=False)
    _device_curr_stamp_ms: float = field(init=False, default=None)
    _device_time_offset: datetime = field(init=False, default=None)
    _host_time_offset: datetime = field(init=False, default=None)
    _update_interval_ms: float = field(init=False, default=0)
    _logger: logging.Logger = field(init=False, default=None)

    def __post_init__(self):
        self.validate_update_rate()
        self._update_interval_ms = 1000 / self._update_rate
        self._logger = logging.getLogger(__name__)
        self.set_host_time_offset()

    def validate_update_rate(self):
        """
        Validate the update rate.
        """
        if self._update_rate not in [20, 50, 100]:
            raise ValueError("Update rate must be 20, 50 or 100")

    @property
    def update_interval_ms(self):
        """
        Time interval between samples in milliseconds.
        """
        return self._update_interval_ms

    @property
    def update_rate(self):
        """
        Update rate in Hz.
        """
        return self._update_rate

    @staticmethod
    def timestamp(date_time: Optional[datetime] = None) -> int:
        """
        Returns the current timestamp in milliseconds. It call timestamp() to get the number of seconds since the epoch and multiplies by 1000 to get the number of milliseconds.
        """
        return int((date_time or datetime.now(timezone.utc)).timestamp() * 1000)

    def set_host_time_offset(self) -> None:
        """
        Set the host time offset.
        """
        self._host_time_offset = datetime.now(timezone.utc)
        self._logger.info("Setting host time offset [%s]",
                          self._host_time_offset)

    def _compute_offset_delta_ms(self) -> Optional[float]:
        """
        Compute the offset delta in milliseconds.
        """
        if self._device_time_offset and self._host_time_offset:
            delta = self._host_time_offset - self._device_time_offset
            return delta.total_seconds() * 1000
        else:
            return None

    def stamp_from_host(self) -> float:
        """
        Generate a timestamp from the host.
        """
        if not self._initialized:
            self._device_curr_stamp_ms = 0.0
            self._initialized = True
            return self._device_curr_stamp_ms
        else:
            self._device_curr_stamp_ms += self._update_interval_ms
            return self._device_curr_stamp_ms

    def synchronize(self) -> datetime:
        """
        Synchronize the device time with the host time.
        Returns: datetime object.
        """
        now = datetime.now(timezone.utc)
        self._device_time_offset = now
        self._host_time_offset = now
        return now
