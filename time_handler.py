import struct
import logging
from datetime import datetime, timezone

from attr import define, field

@define
class TimeHandler():
    """
    The TimeHandler class is designed to generate and manage timestamps for measurements from a 
    WT901BLECL5.0 device. Since the WT901BLECL5.0 device does not provide timestamps with its BLE data packets, this class helps the host system generate and synchronize timestamps, either using the host 
    clock or by aligning with the device's time when available.

    The class provide a method to generate WIT messages to update the device's time registers and can 
    be used to synchronize the host and device clocks.

    Note: The SAVE command is omitted intentionally to avoid excessive writes to non-volatile memory, 
    as this update is performed frequently and persistence across power cycles is not required.


    Attributes
    ----------
    _update_rate (float):
        The expected update rate (Hz) for measurements. Used to calculate time intervals between samples.
    _initialized (bool):
        Tracks whether the handler has been initialized (first stamp generated).
    _device_curr_stamp_ms (float):
        Current timestamp in milliseconds, as tracked by the device or generated by the host.
    _device_time_offset (datetime):
        Device's reference time (not set in this code, but placeholder for future use).
    _host_time_offset (datetime):
        Host's reference time, set when set_host_time_offset() is called.
    _update_interval_ms (float):
        Time interval between samples in milliseconds. 
    """
    _update_rate: int = field(init=True, default=0)
    _initialized: bool = field(init=False, default=False)
    _device_curr_stamp_ms: float = field(init=False, default=None)
    _device_time_offset: datetime= field(init=False, default=None)
    _host_time_offset: datetime = field(init=False, default=None)
    _update_interval_ms: float = field(init=False, default=0)
    _logger: logging.Logger = field(init=False, default=None)

    def __attrs_post_init__(self):
        if self._update_rate == 0:
            raise ValueError("Update rate must be greater than 0")
        self._update_interval_ms = 1000 / self._update_rate
        self._logger = logging.getLogger(__name__)

    @property
    def update_interval_ms(self):
        return self._update_interval_ms

    @property
    def update_rate(self):
        return self._update_rate

    def set_host_time_offset(self):
        self._host_time_offset = datetime.now(timezone.utc)
        self._logger.info(
            f"host time offset {self._host_time_offset}, "
            f"device time offset {self._device_time_offset}, "
            f"delta ms {(self._compute_offset_delta_ms())}"
        )
    
    def _compute_offset_delta_ms(self):
        if self._device_time_offset and self._host_time_offset:
            delta = self._host_time_offset - self._device_time_offset
            return delta.total_seconds() * 1000
        return None

    def stamp_from_host(self):
        if not self._initialized:
            self._device_curr_stamp_ms = 0.0
            self._initialized = True
            return self._device_curr_stamp_ms
        else:
            self._device_curr_stamp_ms += self._update_interval_ms
            return self._device_curr_stamp_ms

    def synchronize(self) -> datetime:
        """
        Returns the current time to be sent to the device.
        Returns: datetime object.
        """
        now =  datetime.now(timezone.utc)
        self._device_time_offset = now
        self._host_time_offset = now
        return now

    